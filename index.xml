<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>All Things Yogesh</title>
    <link>https://yogeshdhamija.github.io/</link>
    <description>Recent content on All Things Yogesh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Feb 2021 18:19:59 -0600</lastBuildDate>
    
        <atom:link href="https://yogeshdhamija.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Chicken Curry</title>
        <link>https://yogeshdhamija.github.io/recipes/chicken-curry/</link>
        <pubDate>Tue, 02 Feb 2021 18:19:59 -0600</pubDate>
        
        <guid>https://yogeshdhamija.github.io/recipes/chicken-curry/</guid>
        <description>All Things Yogesh https://yogeshdhamija.github.io/recipes/chicken-curry/ -&lt;p&gt;~5 servings.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Into a deep pan on stove:&lt;/strong&gt;&lt;br&gt;
9 tablespoons oil&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When hot, add and constantly stir:&lt;/strong&gt;&lt;br&gt;
3 bay leaves&lt;br&gt;
12 cloves&lt;br&gt;
6-inch cinnamon piece&lt;br&gt;
9 green cardamom&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After about a minute, add and constantly stir:&lt;/strong&gt;&lt;br&gt;
3 cup onions, finely chopped&lt;br&gt;
6 thai green chilis, slit&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When onions are golden, add and constantly stir:&lt;/strong&gt;&lt;br&gt;
1.5 tablespoons ginger, minced&lt;br&gt;
1.5 tablespoons garlic, minced&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After about a minute, add and constantly stir:&lt;/strong&gt;&lt;br&gt;
1.5 cup tomatoes, finely chopped&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When tomatoes mushy, stir in:&lt;/strong&gt;&lt;br&gt;
1 cup yoghurt&lt;br&gt;
0.75 tsp turmeric&lt;br&gt;
3 tsp cayanne pepper&lt;br&gt;
3 tsp garam masala&lt;br&gt;
3 tsp coriander&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When yoghurt smell goes away, stir in:&lt;/strong&gt;&lt;br&gt;
3 lbs chicken breast, cubed&lt;br&gt;
6 tbsp cilantro leaves, minced&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fry chicken, flipping occasionally, until white (about 3 minutes).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cover and cook for about 4 minutes, stirring occasionally.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stir in:&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;??? cup hot water&lt;/em&gt; (enough to make a thick curry)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cover and cook on low flame, stirring occasionally, until chicken is soft-cooked.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Source: &lt;a href=&#34;https://www.indianhealthyrecipes.com/chicken-curry/&#34;&gt;&amp;ldquo;Chicken Curry Recipe&amp;rdquo;, by Swasthi&lt;/a&gt;.&lt;/p&gt;
- https://yogeshdhamija.github.io/recipes/chicken-curry/ - </description>
        </item>
    
    
    
        <item>
        <title>Parse, Don&#39;t Validate</title>
        <link>https://yogeshdhamija.github.io/bookmarks/parse-dont-validate/</link>
        <pubDate>Wed, 06 Jan 2021 10:34:25 -0400</pubDate>
        
        <guid>https://yogeshdhamija.github.io/bookmarks/parse-dont-validate/</guid>
        <description>All Things Yogesh https://yogeshdhamija.github.io/bookmarks/parse-dont-validate/ -&lt;p&gt;The source is the article &lt;a href=&#34;https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/&#34;&gt;&amp;ldquo;Parse, don&amp;rsquo;t validate&amp;rdquo;&lt;/a&gt; written by Alexis King.&lt;/p&gt;
&lt;p&gt;Pasted here:&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Historically, I&amp;rsquo;ve struggled to find a concise, simple way to explain what it means to practice type-driven design. Too often, when someone asks me &amp;ldquo;How did you come up with this approach?&amp;rdquo; I find I can&amp;rsquo;t give them a satisfying answer. I know it didn&amp;rsquo;t just come to me in a vision&amp;mdash;I have an iterative design process that doesn&amp;rsquo;t require plucking the &amp;ldquo;right&amp;rdquo; approach out of thin air&amp;mdash;yet I haven&amp;rsquo;t been very successful in communicating that process to others.&lt;/p&gt;
&lt;p&gt;However, about a month ago, &lt;a href=&#34;https://twitter.com/lexi_lambda/status/1182242561655746560&#34;&gt;I was reflecting on Twitter&lt;/a&gt; about the differences I experienced parsing JSON in statically- and dynamically-typed languages, and finally, I realized what I was looking for. Now I have a single, snappy slogan that encapsulates what type-driven design means to me, and better yet, it&amp;rsquo;s only three words long:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Parse, don&amp;rsquo;t validate.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;the-essence-of-type-driven-design&#34;&gt;The essence of type-driven design&lt;/h1&gt;
&lt;p&gt;Alright, I&amp;rsquo;ll confess: unless you already know what type-driven design is, my catchy slogan probably doesn&amp;rsquo;t mean all that much to you. Fortunately, that&amp;rsquo;s what the remainder of this blog post is for. I&amp;rsquo;m going to explain precisely what I mean in gory detail&amp;mdash;but first, we need to practice a little wishful thinking.&lt;/p&gt;
&lt;h2 id=&#34;the-realm-of-possibility&#34;&gt;The realm of possibility&lt;/h2&gt;
&lt;p&gt;One of the wonderful things about static type systems is that they can make it possible, and sometimes even easy, to answer questions like &amp;ldquo;is it possible to write this function?&amp;rdquo; For an extreme example, consider the following Haskell type signature:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo :: Integer -&amp;gt; Void 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is it possible to implement &lt;code&gt;foo&lt;/code&gt;? Trivially, the answer is &lt;em&gt;no&lt;/em&gt;, as &lt;code&gt;Void&lt;/code&gt; is a type that contains no values, so it&amp;rsquo;s impossible for &lt;em&gt;any&lt;/em&gt; function to produce a value of type &lt;code&gt;Void&lt;/code&gt;.&lt;a href=&#34;https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/#2019-11-05-parse-don-t-validate-footnote-1-definition&#34;&gt;1&lt;/a&gt; That example is pretty boring, but the question gets much more interesting if we choose a more realistic example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head :: [a] -&amp;gt; a 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function returns the first element from a list. Is it possible to implement? It certainly doesn&amp;rsquo;t sound like it does anything very complicated, but if we attempt to implement it, the compiler won&amp;rsquo;t be satisfied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head :: [a] -&amp;gt; a head (x:_) = x 

warning: [-Wincomplete-patterns] Pattern match(es) are non-exhaustive In an equation for ‘head’: Patterns not matched: []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This message is helpfully pointing out that our function is &lt;em&gt;partial&lt;/em&gt;, which is to say it is not defined for all possible inputs. Specifically, it is not defined when the input is &lt;code&gt;[]&lt;/code&gt;, the empty list. This makes sense, as it isn&amp;rsquo;t possible to return the first element of a list if the list is empty&amp;mdash;there&amp;rsquo;s no element to return! So, remarkably, we learn this function isn&amp;rsquo;t possible to implement, either.&lt;/p&gt;
&lt;h2 id=&#34;turning-partial-functions-total&#34;&gt;Turning partial functions total&lt;/h2&gt;
&lt;p&gt;To someone coming from a dynamically-typed background, this might seem perplexing. If we have a list, we might very well want to get the first element in it. And indeed, the operation of &amp;ldquo;getting the first element of a list&amp;rdquo; isn&amp;rsquo;t impossible in Haskell, it just requires a little extra ceremony. There are two different ways to fix the &lt;code&gt;head&lt;/code&gt; function, and we&amp;rsquo;ll start with the simplest one.&lt;/p&gt;
&lt;h3 id=&#34;managing-expectations&#34;&gt;Managing expectations&lt;/h3&gt;
&lt;p&gt;As established, &lt;code&gt;head&lt;/code&gt; is partial because there is no element to return if the list is empty: we&amp;rsquo;ve made a promise we cannot possibly fulfill. Fortunately, there&amp;rsquo;s an easy solution to that dilemma: we can weaken our promise. Since we cannot guarantee the caller an element of the list, we&amp;rsquo;ll have to practice a little expectation management: we&amp;rsquo;ll do our best return an element if we can, but we reserve the right to return nothing at all. In Haskell, we express this possibility using the &lt;code&gt;Maybe&lt;/code&gt; type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head :: [a] -&amp;gt; Maybe a 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This buys us the freedom we need to implement &lt;code&gt;head&lt;/code&gt;&amp;mdash;it allows us to return &lt;code&gt;Nothing&lt;/code&gt; when we discover we can&amp;rsquo;t produce a value of type &lt;code&gt;a&lt;/code&gt; after all:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head :: [a] -&amp;gt; Maybe a head (x:_) = Just x head [] = Nothing 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Problem solved, right? For the moment, yes&amp;hellip; but this solution has a hidden cost.&lt;/p&gt;
&lt;p&gt;Returning &lt;code&gt;Maybe&lt;/code&gt; is undoubtably convenient when we&amp;rsquo;re &lt;em&gt;implementing&lt;/em&gt; &lt;code&gt;head&lt;/code&gt;. However, it becomes significantly less convenient when we want to actually use it! Since &lt;code&gt;head&lt;/code&gt; always has the potential to return &lt;code&gt;Nothing&lt;/code&gt;, the burden falls upon its callers to handle that possibility, and sometimes that passing of the buck can be incredibly frustrating. To see why, consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getConfigurationDirectories :: IO [FilePath] getConfigurationDirectories = do configDirsString &amp;lt;- getEnv &amp;quot;CONFIG_DIRS&amp;quot; let configDirsList = split &#39;,&#39; configDirsString when (null configDirsList) $ throwIO $ userError &amp;quot;CONFIG_DIRS cannot be empty&amp;quot; pure configDirsList main :: IO () main = do configDirs &amp;lt;- getConfigurationDirectories case head configDirs of Just cacheDir -&amp;gt; initializeCache cacheDir Nothing -&amp;gt; error &amp;quot;should never happen; already checked configDirs is non-empty&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When &lt;code&gt;getConfigurationDirectories&lt;/code&gt; retrieves a list of file paths from the environment, it proactively checks that the list is non-empty. However, when we use &lt;code&gt;head&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt; to get the first element of the list, the &lt;code&gt;Maybe FilePath&lt;/code&gt; result still requires us to handle a &lt;code&gt;Nothing&lt;/code&gt; case that we know will never happen! This is terribly bad for several reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;First, it&amp;rsquo;s just annoying. We already checked that the list is non-empty, why do we have to clutter our code with another redundant check?&lt;/li&gt;
&lt;li&gt;Second, it has a potential performance cost. Although the cost of the redundant check is trivial in this particular example, one could imagine a more complex scenario where the redundant checks could add up, such as if they were happening in a tight loop.&lt;/li&gt;
&lt;li&gt;Finally, and worst of all, this code is a bug waiting to happen! What if &lt;code&gt;getConfigurationDirectories&lt;/code&gt; were modified to stop checking that the list is empty, intentionally or unintentionally? The programmer might not remember to update &lt;code&gt;main&lt;/code&gt;, and suddenly the &amp;ldquo;impossible&amp;rdquo; error becomes not only possible, but probable.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The need for this redundant check has essentially forced us to punch a hole in our type system. If we could statically &lt;em&gt;prove&lt;/em&gt; the &lt;code&gt;Nothing&lt;/code&gt; case impossible, then a modification to &lt;code&gt;getConfigurationDirectories&lt;/code&gt; that stopped checking if the list was empty would invalidate the proof and trigger a compile-time failure. However, as-written, we&amp;rsquo;re forced to rely on a test suite or manual inspection to catch the bug.&lt;/p&gt;
&lt;h3 id=&#34;paying-it-forward&#34;&gt;Paying it forward&lt;/h3&gt;
&lt;p&gt;Clearly, our modified version of &lt;code&gt;head&lt;/code&gt; leaves some things to be desired. Somehow, we&amp;rsquo;d like it to be smarter: if we already checked that the list was non-empty, &lt;code&gt;head&lt;/code&gt; should unconditionally return the first element without forcing us to handle the case we know is impossible. How can we do that?&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look at the original (partial) type signature for &lt;code&gt;head&lt;/code&gt; again:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head :: [a] -&amp;gt; a 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The previous section illustrated that we can turn that partial type signature into a total one by weakening the promise made in the return type. However, since we don&amp;rsquo;t want to do that, there&amp;rsquo;s only one thing left that can be changed: the argument type (in this case, &lt;code&gt;[a]&lt;/code&gt;). Instead of weakening the return type, we can &lt;em&gt;strengthen&lt;/em&gt; the argument type, eliminating the possibility of &lt;code&gt;head&lt;/code&gt; ever being called on an empty list in the first place.&lt;/p&gt;
&lt;p&gt;To do this, we need a type that represents non-empty lists. Fortunately, the existing &lt;code&gt;NonEmpty&lt;/code&gt; type from &lt;code&gt;Data.List.NonEmpty&lt;/code&gt; is exactly that. It has the following definition:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data NonEmpty a = a :| [a] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that &lt;code&gt;NonEmpty a&lt;/code&gt; is really just a tuple of an &lt;code&gt;a&lt;/code&gt; and an ordinary, possibly-empty &lt;code&gt;[a]&lt;/code&gt;. This conveniently models a non-empty list by storing the first element of the list separately from the list&amp;rsquo;s tail: even if the &lt;code&gt;[a]&lt;/code&gt; component is &lt;code&gt;[]&lt;/code&gt;, the &lt;code&gt;a&lt;/code&gt; component must always be present. This makes &lt;code&gt;head&lt;/code&gt; completely trivial to implement:&lt;a href=&#34;https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/#2019-11-05-parse-don-t-validate-footnote-2-definition&#34;&gt;2&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head :: NonEmpty a -&amp;gt; a head (x:|_) = x 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unlike before, GHC accepts this definition without complaint&amp;mdash;this definition is &lt;em&gt;total&lt;/em&gt;, not partial. We can update our program to use the new implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getConfigurationDirectories :: IO (NonEmpty FilePath) getConfigurationDirectories = do configDirsString &amp;lt;- getEnv &amp;quot;CONFIG_DIRS&amp;quot; let configDirsList = split &#39;,&#39; configDirsString case nonEmpty configDirsList of Just nonEmptyConfigDirsList -&amp;gt; pure nonEmptyConfigDirsList Nothing -&amp;gt; throwIO $ userError &amp;quot;CONFIG_DIRS cannot be empty&amp;quot; main :: IO () main = do configDirs &amp;lt;- getConfigurationDirectories initializeCache (head configDirs) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the redundant check in &lt;code&gt;main&lt;/code&gt; is now completely gone! Instead, we perform the check exactly once, in &lt;code&gt;getConfigurationDirectories&lt;/code&gt;. It constructs a &lt;code&gt;NonEmpty a&lt;/code&gt; from a &lt;code&gt;[a]&lt;/code&gt; using the &lt;code&gt;nonEmpty&lt;/code&gt; function from &lt;code&gt;Data.List.NonEmpty&lt;/code&gt;, which has the following type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nonEmpty :: [a] -&amp;gt; Maybe (NonEmpty a) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Maybe&lt;/code&gt; is still there, but this time, we handle the &lt;code&gt;Nothing&lt;/code&gt; case very early in our program: right in the same place we were already doing the input validation. Once that check has passed, we now have a &lt;code&gt;NonEmpty FilePath&lt;/code&gt; value, which preserves (in the type system!) the knowledge that the list really is non-empty. Put another way, you can think of a value of type &lt;code&gt;NonEmpty a&lt;/code&gt; as being like a value of type &lt;code&gt;[a]&lt;/code&gt;, plus a &lt;em&gt;proof&lt;/em&gt; that the list is non-empty.&lt;/p&gt;
&lt;p&gt;By strengthening the type of the argument to &lt;code&gt;head&lt;/code&gt; instead of weakening the type of its result, we&amp;rsquo;ve completely eliminated all the problems from the previous section:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The code has no redundant checks, so there can&amp;rsquo;t be any performance overhead.&lt;/li&gt;
&lt;li&gt;Furthermore, if &lt;code&gt;getConfigurationDirectories&lt;/code&gt; changes to stop checking that the list is non-empty, its return type must change, too. Consequently, &lt;code&gt;main&lt;/code&gt; will fail to typecheck, alerting us to the problem before we even run the program!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What&amp;rsquo;s more, it&amp;rsquo;s trivial to recover the old behavior of &lt;code&gt;head&lt;/code&gt; from the new one by composing &lt;code&gt;head&lt;/code&gt; with &lt;code&gt;nonEmpty&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head&#39; :: [a] -&amp;gt; Maybe a head&#39; = fmap head . nonEmpty 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the inverse is &lt;em&gt;not&lt;/em&gt; true: there is no way to obtain the new version of &lt;code&gt;head&lt;/code&gt; from the old one. All in all, the second approach is superior on all axes.&lt;/p&gt;
&lt;h2 id=&#34;the-power-of-parsing&#34;&gt;The power of parsing&lt;/h2&gt;
&lt;p&gt;You may be wondering what the above example has to do with the title of this blog post. After all, we only examined two different ways to validate that a list was non-empty&amp;mdash;no parsing in sight. That interpretation isn&amp;rsquo;t wrong, but I&amp;rsquo;d like to propose another perspective: in my mind, the difference between validation and parsing lies almost entirely in how information is preserved. Consider the following pair of functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;validateNonEmpty :: [a] -&amp;gt; IO () validateNonEmpty (_:_) = pure () validateNonEmpty [] = throwIO $ userError &amp;quot;list cannot be empty&amp;quot; parseNonEmpty :: [a] -&amp;gt; IO (NonEmpty a) parseNonEmpty (x:xs) = pure (x:|xs) parseNonEmpty [] = throwIO $ userError &amp;quot;list cannot be empty&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These two functions are nearly identical: they check if the provided list is empty, and if it is, they abort the program with an error message. The difference lies entirely in the return type: &lt;code&gt;validateNonEmpty&lt;/code&gt; always returns &lt;code&gt;()&lt;/code&gt;, the type that contains no information, but &lt;code&gt;parseNonEmpty&lt;/code&gt; returns &lt;code&gt;NonEmpty a&lt;/code&gt;, a refinement of the input type that preserves the knowledge gained in the type system. Both of these functions check the same thing, but &lt;code&gt;parseNonEmpty&lt;/code&gt; gives the caller access to the information it learned, while &lt;code&gt;validateNonEmpty&lt;/code&gt; just throws it away.&lt;/p&gt;
&lt;p&gt;These two functions elegantly illustrate two different perspectives on the role of a static type system: &lt;code&gt;validateNonEmpty&lt;/code&gt; obeys the typechecker well enough, but only &lt;code&gt;parseNonEmpty&lt;/code&gt; takes full advantage of it. If you see why &lt;code&gt;parseNonEmpty&lt;/code&gt; is preferable, you understand what I mean by the mantra &amp;ldquo;parse, don&amp;rsquo;t validate.&amp;rdquo; Still, perhaps you are skeptical of &lt;code&gt;parseNonEmpty&lt;/code&gt;&amp;rsquo;s name. Is it really &lt;em&gt;parsing&lt;/em&gt; anything, or is it merely validating its input and returning a result? While the precise definition of what it means to parse or validate something is debatable, I believe &lt;code&gt;parseNonEmpty&lt;/code&gt; is a bona-fide parser (albeit a particularly simple one).&lt;/p&gt;
&lt;p&gt;Consider: what is a parser? Really, a parser is just a function that consumes less-structured input and produces more-structured output. By its very nature, a parser is a partial function&amp;mdash;some values in the domain do not correspond to any value in the range&amp;mdash;so all parsers must have some notion of failure. Often, the input to a parser is text, but this is by no means a requirement, and &lt;code&gt;parseNonEmpty&lt;/code&gt; is a perfectly cromulent parser: it parses lists into non-empty lists, signaling failure by terminating the program with an error message.&lt;/p&gt;
&lt;p&gt;Under this flexible definition, parsers are an incredibly powerful tool: they allow discharging checks on input up-front, right on the boundary between a program and the outside world, and once those checks have been performed, they never need to be checked again! Haskellers are well-aware of this power, and they use many different types of parsers on a regular basis:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/aeson&#34;&gt;aeson&lt;/a&gt; library provides a &lt;code&gt;Parser&lt;/code&gt; type that can be used to parse JSON data into domain types.&lt;/li&gt;
&lt;li&gt;Likewise, &lt;a href=&#34;https://hackage.haskell.org/package/optparse-applicative&#34;&gt;optparse-applicative&lt;/a&gt; provides a set of parser combinators for parsing command-line arguments.&lt;/li&gt;
&lt;li&gt;Database libraries like &lt;a href=&#34;https://hackage.haskell.org/package/persistent&#34;&gt;persistent&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple&#34;&gt;postgresql-simple&lt;/a&gt; have a mechanism for parsing values held in an external data store.&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/servant&#34;&gt;servant&lt;/a&gt; ecosystem is built around parsing Haskell datatypes from path components, query parameters, HTTP headers, and more.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The common theme between all these libraries is that they sit on the boundary between your Haskell application and the external world. That world doesn&amp;rsquo;t speak in product and sum types, but in streams of bytes, so there&amp;rsquo;s no getting around a need to do some parsing. Doing that parsing up front, before acting on the data, can go a long way toward avoiding many classes of bugs, some of which might even be security vulnerabilities.&lt;/p&gt;
&lt;p&gt;One drawback to this approach of parsing everything up front is that it sometimes requires values be parsed long before they are actually used. In a dynamically-typed language, this can make keeping the parsing and processing logic in sync a little tricky without extensive test coverage, much of which can be laborious to maintain. However, with a static type system, the problem becomes marvelously simple, as demonstrated by the &lt;code&gt;NonEmpty&lt;/code&gt; example above: if the parsing and processing logic go out of sync, the program will fail to even compile.&lt;/p&gt;
&lt;h2 id=&#34;the-danger-of-validation&#34;&gt;The danger of validation&lt;/h2&gt;
&lt;p&gt;Hopefully, by this point, you are at least somewhat sold on the idea that parsing is preferable to validation, but you may have lingering doubts. Is validation really so bad if the type system is going to force you to do the necessary checks eventually anyway? Maybe the error reporting will be a little bit worse, but a bit of redundant checking can&amp;rsquo;t hurt, right?&lt;/p&gt;
&lt;p&gt;Unfortunately, it isn&amp;rsquo;t so simple. Ad-hoc validation leads to a phenomenon that the &lt;a href=&#34;http://langsec.org/&#34;&gt;language-theoretic security&lt;/a&gt; field calls &lt;em&gt;shotgun parsing&lt;/em&gt;. In the 2016 paper, &lt;a href=&#34;http://langsec.org/papers/langsec-cwes-secdev2016.pdf&#34;&gt;The Seven Turrets of Babel: A Taxonomy of LangSec Errors and How to Expunge Them&lt;/a&gt;, its authors provide the following definition:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Shotgun parsing is a programming antipattern whereby parsing and input-validating code is mixed with and spread across processing code&amp;mdash;throwing a cloud of checks at the input, and hoping, without any systematic justification, that one or another would catch all the &amp;ldquo;bad&amp;rdquo; cases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;They go on to explain the problems inherent to such validation techniques:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Shotgun parsing necessarily deprives the program of the ability to reject invalid input instead of processing it. Late-discovered errors in an input stream will result in some portion of invalid input having been processed, with the consequence that program state is difficult to accurately predict.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In other words, a program that does not parse all of its input up front runs the risk of acting upon a valid portion of the input, discovering a different portion is invalid, and suddenly needing to roll back whatever modifications it already executed in order to maintain consistency. Sometimes this is possible&amp;mdash;such as rolling back a transaction in an RDBMS&amp;mdash;but in general it may not be.&lt;/p&gt;
&lt;p&gt;It may not be immediately apparent what shotgun parsing has to do with validation&amp;mdash;after all, if you do all your validation up front, you mitigate the risk of shotgun parsing. The problem is that validation-based approaches make it extremely difficult or impossible to determine if everything was actually validated up front or if some of those so-called &amp;ldquo;impossible&amp;rdquo; cases might actually happen. The entire program must assume that raising an exception anywhere is not only possible, it&amp;rsquo;s regularly necessary.&lt;/p&gt;
&lt;p&gt;Parsing avoids this problem by stratifying the program into two phases&amp;mdash;parsing and execution&amp;mdash;where failure due to invalid input can only happen in the first phase. The set of remaining failure modes during execution is minimal by comparison, and they can be handled with the tender care they require.&lt;/p&gt;
&lt;h1 id=&#34;parsing-not-validating-in-practice&#34;&gt;Parsing, not validating, in practice&lt;/h1&gt;
&lt;p&gt;So far, this blog post has been something of a sales pitch. &amp;ldquo;You, dear reader, ought to be parsing!&amp;rdquo; it says, and if I&amp;rsquo;ve done my job properly, at least some of you are sold. However, even if you understand the &amp;ldquo;what&amp;rdquo; and the &amp;ldquo;why,&amp;rdquo; you might not feel especially confident about the &amp;ldquo;how.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;My advice: focus on the datatypes.&lt;/p&gt;
&lt;p&gt;Suppose you are writing a function that accepts a list of tuples representing key-value pairs, and you suddenly realize you aren&amp;rsquo;t sure what to do if the list has duplicate keys. One solution would be to write a function that asserts there aren&amp;rsquo;t any duplicates in the list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;checkNoDuplicateKeys :: (MonadError AppError m, Eq k) =&amp;gt; [(k, v)] -&amp;gt; m () 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, this check is fragile: it&amp;rsquo;s extremely easy to forget. Because its return value is unused, it can always be omitted, and the code that needs it would still typecheck. A better solution is to choose a data structure that disallows duplicate keys by construction, such as a &lt;code&gt;Map&lt;/code&gt;. Adjust your function&amp;rsquo;s type signature to accept a &lt;code&gt;Map&lt;/code&gt; instead of a list of tuples, and implement it as you normally would.&lt;/p&gt;
&lt;p&gt;Once you&amp;rsquo;ve done that, the call site of your new function will likely fail to typecheck, since it is still being passed a list of tuples. If the caller was given the value via one of its arguments, or if it received it from the result of some other function, you can continue updating the type from list to &lt;code&gt;Map&lt;/code&gt;, all the way up the call chain. Eventually, you will either reach the location the value is created, or you&amp;rsquo;ll find a place where duplicates actually ought to be allowed. At that point, you can insert a call to a modified version of &lt;code&gt;checkNoDuplicateKeys&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;checkNoDuplicateKeys :: (MonadError AppError m, Eq k) =&amp;gt; [(k, v)] -&amp;gt; m (Map k v) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the check &lt;em&gt;cannot&lt;/em&gt; be omitted, since its result is actually necessary for the program to proceed!&lt;/p&gt;
&lt;p&gt;This hypothetical scenario highlights two simple ideas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Use a data structure that makes illegal states unrepresentable.&lt;/strong&gt; Model your data using the most precise data structure you reasonably can. If ruling out a particular possibility is too hard using the encoding you are currently using, consider alternate encodings that can express the property you care about more easily. Don&amp;rsquo;t be afraid to refactor.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Push the burden of proof upward as far as possible, but no further.&lt;/strong&gt; Get your data into the most precise representation you need as quickly as you can. Ideally, this should happen at the boundary of your system, before &lt;em&gt;any&lt;/em&gt; of the data is acted upon.&lt;a href=&#34;https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/#2019-11-05-parse-don-t-validate-footnote-3-definition&#34;&gt;3&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If one particular code branch eventually requires a more precise representation of a piece of data, parse the data into the more precise representation as soon as the branch is selected. Use sum types judiciously to allow your datatypes to reflect and adapt to control flow.&lt;/p&gt;
&lt;p&gt;In other words, write functions on the data representation you &lt;em&gt;wish&lt;/em&gt; you had, not the data representation you are given. The design process then becomes an exercise in bridging the gap, often by working from both ends until they meet somewhere in the middle. Don&amp;rsquo;t be afraid to iteratively adjust parts of the design as you go, since you may learn something new during the refactoring process!&lt;/p&gt;
&lt;p&gt;Here are a handful of additional points of advice, arranged in no particular order:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Let your datatypes inform your code, don&amp;rsquo;t let your code control your datatypes.&lt;/strong&gt; Avoid the temptation to just stick a &lt;code&gt;Bool&lt;/code&gt; in a record somewhere because it&amp;rsquo;s needed by the function you&amp;rsquo;re currently writing. Don&amp;rsquo;t be afraid to refactor code to use the right data representation&amp;mdash;the type system will ensure you&amp;rsquo;ve covered all the places that need changing, and it will likely save you a headache later.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Treat functions that return &lt;code&gt;m ()&lt;/code&gt; with deep suspicion.&lt;/strong&gt; Sometimes these are genuinely necessary, as they may perform an imperative effect with no meaningful result, but if the primary purpose of that effect is raising an error, it&amp;rsquo;s likely there&amp;rsquo;s a better way.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Don&amp;rsquo;t be afraid to parse data in multiple passes.&lt;/strong&gt; Avoiding shotgun parsing just means you shouldn&amp;rsquo;t act on the input data before it&amp;rsquo;s fully parsed, not that you can&amp;rsquo;t use some of the input data to decide how to parse other input data. Plenty of useful parsers are context-sensitive.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Avoid denormalized representations of data, &lt;em&gt;especially&lt;/em&gt; if it&amp;rsquo;s mutable.&lt;/strong&gt; Duplicating the same data in multiple places introduces a trivially representable illegal state: the places getting out of sync. Strive for a single source of truth.
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Keep denormalized representations of data behind abstraction boundaries.&lt;/strong&gt; If denormalization is absolutely necessary, use encapsulation to ensure a small, trusted module holds sole responsibility for keeping the representations in sync.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use abstract datatypes to make validators &amp;ldquo;look like&amp;rdquo; parsers.&lt;/strong&gt; Sometimes, making an illegal state truly unrepresentable is just plain impractical given the tools Haskell provides, such as ensuring an integer is in a particular range. In that case, use an abstract &lt;code&gt;newtype&lt;/code&gt; with a smart constructor to &amp;ldquo;fake&amp;rdquo; a parser from a validator.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As always, use your best judgement. It probably isn&amp;rsquo;t worth breaking out &lt;a href=&#34;https://hackage.haskell.org/package/singletons&#34;&gt;singletons&lt;/a&gt; and refactoring your entire application just to get rid of a single &lt;code&gt;error &amp;quot;impossible&amp;quot;&lt;/code&gt; call somewhere&amp;mdash;just make sure to treat those situations like the radioactive substance they are, and handle them with the appropriate care. If all else fails, at least leave a comment to document the invariant for whoever needs to modify the code next.&lt;/p&gt;
&lt;h1 id=&#34;recap-reflection-and-related-reading&#34;&gt;Recap, reflection, and related reading&lt;/h1&gt;
&lt;p&gt;That&amp;rsquo;s all, really. Hopefully this blog post proves that taking advantage of the Haskell type system doesn&amp;rsquo;t require a PhD, and it doesn&amp;rsquo;t even require using the latest and greatest of GHC&amp;rsquo;s shiny new language extensions&amp;mdash;though they can certainly sometimes help! Sometimes the biggest obstacle to using Haskell to its fullest is simply being aware what options are available, and unfortunately, one downside of Haskell&amp;rsquo;s small community is a relative dearth of resources that document design patterns and techniques that have become tribal knowledge.&lt;/p&gt;
&lt;p&gt;None of the ideas in this blog post are new. In fact, the core idea&amp;mdash;&amp;ldquo;write total functions&amp;rdquo;&amp;mdash;is conceptually quite simple. Despite that, I find it remarkably challenging to communicate actionable, practicable details about the way I write Haskell code. It&amp;rsquo;s easy to spend lots of time talking about abstract concepts&amp;mdash;many of which are quite valuable!&amp;mdash;without communicating anything useful about &lt;em&gt;process&lt;/em&gt;. My hope is that this is a small step in that direction.&lt;/p&gt;
&lt;p&gt;Sadly, I don&amp;rsquo;t know very many other resources on this particular topic, but I do know of one: I never hesitate to recommend Matt Parson&amp;rsquo;s fantastic blog post &lt;a href=&#34;https://www.parsonsmatt.org/2017/10/11/type_safety_back_and_forth.html&#34;&gt;Type Safety Back and Forth&lt;/a&gt;. If you want another accessible perspective on these ideas, including another worked example, I&amp;rsquo;d highly encourage giving it a read. For a significantly more advanced take on many of these ideas, I can also recommend Matt Noonan&amp;rsquo;s 2018 paper &lt;a href=&#34;https://kataskeue.com/gdp.pdf&#34;&gt;Ghosts of Departed Proofs&lt;/a&gt;, which outlines a handful of techniques for capturing more complex invariants in the type system than I have described here.&lt;/p&gt;
&lt;p&gt;As a closing note, I want to say that doing the kind of refactoring described in this blog post is not always easy. The examples I&amp;rsquo;ve given are simple, but real life is often much less straightforward. Even for those experienced in type-driven design, it can be genuinely difficult to capture certain invariants in the type system, so do not consider it a personal failing if you cannot solve something the way you&amp;rsquo;d like! Consider the principles in this blog post ideals to strive for, not strict requirements to meet. All that matters is to try.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Technically, in Haskell, this ignores &amp;ldquo;bottoms,&amp;rdquo; constructions that can inhabit &lt;em&gt;any&lt;/em&gt; value. These aren&amp;rsquo;t &amp;ldquo;real&amp;rdquo; values (unlike &lt;code&gt;null&lt;/code&gt; in some other languages)&amp;mdash;they&amp;rsquo;re things like infinite loops or computations that raise exceptions&amp;mdash;and in idiomatic Haskell, we usually try to avoid them, so reasoning that pretends they don&amp;rsquo;t exist still has value. But don&amp;rsquo;t take my word for it&amp;mdash;I&amp;rsquo;ll let Danielsson et al. convince you that &lt;a href=&#34;https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf&#34;&gt;Fast and Loose Reasoning is Morally Correct&lt;/a&gt;. &lt;a href=&#34;https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/#2019-11-05-parse-don-t-validate-footnote-1-return&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;In fact, &lt;code&gt;Data.List.NonEmpty&lt;/code&gt; already provides a &lt;code&gt;head&lt;/code&gt; function with this type, but just for the sake of illustration, we&amp;rsquo;ll reimplement it ourselves. &lt;a href=&#34;https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/#2019-11-05-parse-don-t-validate-footnote-2-return&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sometimes it is necessary to perform some kind of authorization before parsing user input to avoid denial of service attacks, but that&amp;rsquo;s okay: authorization should have a relatively small surface area, and it shouldn&amp;rsquo;t cause any significant modifications to the state of your system. &lt;a href=&#34;https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/#2019-11-05-parse-don-t-validate-footnote-3-return&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://yogeshdhamija.github.io/bookmarks/parse-dont-validate/ - </description>
        </item>
    
    
    
        <item>
        <title>Git State Diagram</title>
        <link>https://yogeshdhamija.github.io/notes/git-state-diagram/</link>
        <pubDate>Mon, 09 Nov 2020 22:26:22 -0500</pubDate>
        
        <guid>https://yogeshdhamija.github.io/notes/git-state-diagram/</guid>
        <description>All Things Yogesh https://yogeshdhamija.github.io/notes/git-state-diagram/ -&lt;h1 id=&#34;cheat-sheet&#34;&gt;Cheat Sheet&lt;/h1&gt;
&lt;p&gt;General POSIX commands to know:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pwd
cd
ls
mkdir 
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;To clone a repository into the current folder:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone REPO_URL
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;Commands to remember:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git status
git add file1 file2
git commit --message &amp;quot;program does new thing&amp;quot;
git push
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;state-diagram&#34;&gt;State Diagram&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://yogeshdhamija.github.io/gitStateDiagram.drawio.svg&#34; alt=&#34;Git State Diagram&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;how-the-git-directory-works&#34;&gt;How the &lt;code&gt;.git&lt;/code&gt; directory works&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://yogeshdhamija.github.io/gitFolderOrg.drawio.svg&#34; alt=&#34;Git Folder Organization Diagram&#34;&gt;&lt;/p&gt;
- https://yogeshdhamija.github.io/notes/git-state-diagram/ - </description>
        </item>
    
    
    
        <item>
        <title>Website Rendering Strategies</title>
        <link>https://yogeshdhamija.github.io/notes/website-rendering-strategies/</link>
        <pubDate>Thu, 29 Oct 2020 10:34:25 -0400</pubDate>
        
        <guid>https://yogeshdhamija.github.io/notes/website-rendering-strategies/</guid>
        <description>All Things Yogesh https://yogeshdhamija.github.io/notes/website-rendering-strategies/ -&lt;p&gt;Here&amp;rsquo;s a quick summary of the different ways you can load a website.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSR (Server Side Rendering)&lt;/strong&gt;: The classic way. Browser makes request to server, server loads an HTML/CSS/JS bundle, sends it to browser.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSR (Client Side Rendering)&lt;/strong&gt;: The vanilla React way. Browser makes a request to server, server sends back JS code which runs on browser, triggering browser to further make requests to load all assets.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSG (Static Site Generation)&lt;/strong&gt;: The &amp;ldquo;gotta go fast&amp;rdquo; way. Server loads an HTML/CSS/JS bundle for web pages at build time. When browser requests a page, the server just sends this pre-built bundle back&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ISG (Incremental Static Generation)&lt;/strong&gt;: The &amp;ldquo;imma cache stuff&amp;rdquo; way. Server may load some HTML/CSS/JS bundles for web pages at build time. When the browser requests a page, the server sends this pre-built bundle back. If a pre-built bundle doesn&amp;rsquo;t exist, it falls back to CSR while it builds the bundle. (There&amp;rsquo;s more cool variations of this, like auto-rebuilding bundles after a certain time, etc. etc.).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESR (Edge Slice Re-rendering)&lt;/strong&gt;: The &amp;ldquo;this stuff isn&amp;rsquo;t prod-ready, very much in beta&amp;rdquo; way. Server does SSG and tells the CDN to cache the bundles. Then, it instructs the CDN to update the bundle in the event that page content needs to change.&lt;/p&gt;
&lt;p&gt;In order of &lt;strong&gt;performance&lt;/strong&gt;, usually:&lt;br&gt;
(SSG = ISG = ESR) &amp;gt; CSR &amp;gt; SSR&lt;/p&gt;
&lt;p&gt;In order of &lt;strong&gt;SEO&lt;/strong&gt;:&lt;br&gt;
(SSR = SSG = ISG = ESR) &amp;gt; CSR&lt;/p&gt;
&lt;p&gt;In order of &lt;strong&gt;correctness&lt;/strong&gt; (will users be shown &amp;ldquo;stale&amp;rdquo; information?):&lt;br&gt;
(SSR = CSR) &amp;gt; ESR &amp;gt; ISG &amp;gt; SSG&lt;/p&gt;
- https://yogeshdhamija.github.io/notes/website-rendering-strategies/ - </description>
        </item>
    
    
    
        <item>
        <title>Cinnamon Daliya</title>
        <link>https://yogeshdhamija.github.io/recipes/cinnamon-dalia/</link>
        <pubDate>Mon, 31 Aug 2020 04:00:48 +0000</pubDate>
        
        <guid>https://yogeshdhamija.github.io/recipes/cinnamon-dalia/</guid>
        <description>All Things Yogesh https://yogeshdhamija.github.io/recipes/cinnamon-dalia/ -&lt;p&gt;~2 servings&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Into a pot on stove:&lt;/strong&gt;&lt;br&gt;
1 tablespoon butter&lt;br&gt;
0.5 cup daliya (cracked wheat)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stir constantly.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When browned:&lt;/strong&gt;&lt;br&gt;
1.25 cup water&lt;br&gt;
2.11 cup (0.5 liter) milk&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stir constantly.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When reduced and daliya is cooked:&lt;/strong&gt;&lt;br&gt;
1 teaspoon daalchini (cinnamon) powder&lt;br&gt;
honey to taste&lt;br&gt;
slicked almonds as a topping&lt;/p&gt;
- https://yogeshdhamija.github.io/recipes/cinnamon-dalia/ - </description>
        </item>
    
    
    
        <item>
        <title>Chai</title>
        <link>https://yogeshdhamija.github.io/recipes/chai/</link>
        <pubDate>Thu, 16 Jul 2020 18:52:26 -0500</pubDate>
        
        <guid>https://yogeshdhamija.github.io/recipes/chai/</guid>
        <description>All Things Yogesh https://yogeshdhamija.github.io/recipes/chai/ -&lt;p&gt;~4 servings.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Into a large pot on stove:&lt;/strong&gt;&lt;br&gt;
3 cups water&lt;br&gt;
5 tablespoons Assam loose leaf black tea &lt;br&gt;
1 inch ginger (adhrak) sliced&lt;br&gt;
10 cloves (laung)&lt;br&gt;
15 green cardamom pods (elaichi)&lt;br&gt;
2 inch cinnamon (daalchini) stick&lt;br&gt;
15 black peppercorns&lt;br&gt;
5 star anises&lt;br&gt;
0.5 teaspoon fennel seeds (saumph)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When at a low boil:&lt;/strong&gt;&lt;br&gt;
Cover pot&lt;br&gt;
Lower heat to simmer and let it sit&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After at least 10 minutes:&lt;/strong&gt;&lt;br&gt;
3 cups milk&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Source: &lt;a href=&#34;https://medium.com/@harshadkulkarni/the-perfect-indian-masala-chai-4e98fabf42ec&#34;&gt;&amp;ldquo;The Perfect Indian Masala Chai&amp;rdquo;, Medium article by Harshad Kulkarni&lt;/a&gt;, with modifications.&lt;br&gt;
Image attribution: &lt;a href=&#34;https://commons.wikimedia.org/wiki/File:Kullad_chai.jpg&#34;&gt;by Thecuriouseye, on Wikimedia Commons&lt;/a&gt;. Licence: &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/4.0&#34;&gt;CC BY-SA&lt;/a&gt;.&lt;/p&gt;
- https://yogeshdhamija.github.io/recipes/chai/ - </description>
        </item>
    
    
    
        <item>
        <title>Chole</title>
        <link>https://yogeshdhamija.github.io/recipes/chole/</link>
        <pubDate>Fri, 10 Jul 2020 22:28:46 -0500</pubDate>
        
        <guid>https://yogeshdhamija.github.io/recipes/chole/</guid>
        <description>All Things Yogesh https://yogeshdhamija.github.io/recipes/chole/ -&lt;p&gt;~5 servings.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Into a pot on stove:&lt;/strong&gt;&lt;br&gt;
3 cups white chickpeas soaked overnight&lt;br&gt;
&lt;em&gt;??? cups water&lt;/em&gt;  (enough to barely cover the chickpeas)&lt;br&gt;
3 inch cinnamon stick&lt;br&gt;
15 cardamom pods (elaichi)&lt;br&gt;
1.5 bay leaf&lt;br&gt;
1.5 teaspoon ginger paste&lt;br&gt;
0.5 teaspoon baking soda&lt;br&gt;
1.5 teaspoon salt&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After chickpeas cooked al dente:&lt;/strong&gt;&lt;br&gt;
Strain out water and save it&lt;br&gt;
Remove cinnamon, cardamom pods, bay leaves from chickpeas&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Into a large pan on stove:&lt;/strong&gt;&lt;br&gt;
6 tablespoon oil&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When hot:&lt;/strong&gt;&lt;br&gt;
1.5 large onion chopped&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When brown:&lt;/strong&gt;&lt;br&gt;
6 green chillies slit&lt;br&gt;
5.25 medium-sized tomato chopped&lt;br&gt;
1.5 teaspoon ginger chopped&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When soft and mushy:&lt;/strong&gt;&lt;br&gt;
all the chickpeas obtained previously&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After flavours combine (couple minutes):&lt;/strong&gt;&lt;br&gt;
3 teaspoon cumin powder (jira)&lt;br&gt;
3 teaspoon coriander powder (dhaniya)&lt;br&gt;
1.5 teaspoon cayenne (laal mirch)&lt;br&gt;
3 teaspoon garam masaala&lt;br&gt;
&lt;em&gt;??? teaspoon turmeric (haldi)&lt;/em&gt;&lt;br&gt;
lemon squeezed, to taste&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After mixing:&lt;/strong&gt;&lt;br&gt;
until slightly too wet: add stock obtained previously, or water if there&amp;rsquo;s not enough&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reduce until desired consistency&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;Add salt to taste&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Source: &lt;a href=&#34;https://www.vegrecipesofindia.com/amritsari-chole-recipe/&#34;&gt;&amp;ldquo;Amritsari Chole&amp;rdquo;, by Dassana Amit&lt;/a&gt;, with modifications.
Image attribution: &lt;a href=&#34;https://commons.wikimedia.org/wiki/File:Chole_Masala_India.jpg&#34;&gt;by Divya Kudua, on Wikimedia Commons&lt;/a&gt;. Licence: &lt;a href=&#34;https://creativecommons.org/licenses/by/2.0&#34;&gt;CC BY&lt;/a&gt;.&lt;/p&gt;
- https://yogeshdhamija.github.io/recipes/chole/ - </description>
        </item>
    
    
    
        <item>
        <title>CV / Resume</title>
        <link>https://yogeshdhamija.github.io/cv/</link>
        <pubDate>Sun, 28 Jun 2020 17:09:04 -0500</pubDate>
        
        <guid>https://yogeshdhamija.github.io/cv/</guid>
        <description>All Things Yogesh https://yogeshdhamija.github.io/cv/ -
&lt;object data=&#34;/Yogesh Dhamija - CV.pdf&#34; type=&#34;application/pdf&#34; width=&#34;100%&#34; height=&#34;1129px&#34; style=&#34;position:relative; top:-150px; margin-bottom:-150px;&#34;&gt;
    &lt;embed src=&#34;https://yogeshdhamija.github.io/Yogesh Dhamija - CV.pdf&#34;&gt;
        &lt;p&gt;This browser does not support PDFs. Please download the PDF to view it: &lt;a href=&#34;https://yogeshdhamija.github.io/Yogesh Dhamija - CV.pdf&#34;&gt;Download PDF&lt;/a&gt;.&lt;/p&gt;
    &lt;/embed&gt;
&lt;/object&gt;
- https://yogeshdhamija.github.io/cv/ - </description>
        </item>
    
    
    
        <item>
        <title>Tadka</title>
        <link>https://yogeshdhamija.github.io/recipes/tadka/</link>
        <pubDate>Thu, 25 Jun 2020 22:59:28 -0400</pubDate>
        
        <guid>https://yogeshdhamija.github.io/recipes/tadka/</guid>
        <description>All Things Yogesh https://yogeshdhamija.github.io/recipes/tadka/ -&lt;p&gt;&lt;strong&gt;Into a pan on stove:&lt;/strong&gt;&lt;br&gt;
1 tablespoon Olive Oil&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When warm:&lt;/strong&gt;&lt;br&gt;
1/2 teaspoon Cumin seeds (jira)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When brown:&lt;/strong&gt;&lt;br&gt;
1 cups diced Onion&lt;br&gt;
2&amp;quot; piece of root of Ginger (adrak), diced&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When brown:&lt;/strong&gt;&lt;br&gt;
0.5 cups diced Tomato&lt;br&gt;
&lt;em&gt;??? Chilli Pepper&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lower temp, then:&lt;/strong&gt;&lt;br&gt;
2 teaspoon coriander powder (dhaniya)&lt;br&gt;
1/2 teaspoon garam masaala&lt;br&gt;
2 teaspoon cayenne (laal mirch)&lt;br&gt;
1/2 teaspoon salt&lt;br&gt;
1/2 teaspoon turmeric (haldi)&lt;br&gt;
Acid (lemon/lime juice)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Higher temp and mix. Add water if too dry.&lt;/strong&gt;&lt;/p&gt;
- https://yogeshdhamija.github.io/recipes/tadka/ - </description>
        </item>
    
    
    
        <item>
        <title>Mayflies</title>
        <link>https://yogeshdhamija.github.io/writing/mayflies/</link>
        <pubDate>Wed, 24 Jun 2020 15:22:34 -0500</pubDate>
        
        <guid>https://yogeshdhamija.github.io/writing/mayflies/</guid>
        <description>All Things Yogesh https://yogeshdhamija.github.io/writing/mayflies/ -&lt;p&gt;The crowd went silent when the human entered the bar. You didn&amp;rsquo;t see many of their kind here. He grumbled, uncomfortable for the attention, walked up to the counter and signalled for a mug.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s when the whispers started. Mayfly. Young one. The walking dead. He was happy to down his ale.&lt;/p&gt;
&lt;p&gt;You see, this wasn&amp;rsquo;t your average bar. This was a speakeasy, one of the few scattered across the world where the elves and the dwarves shared a drink. Where the seraphim flirted with yokai, while fae fluttered from table to table. Where the orcs played chess at their own table, practically drowning themselves in ale. Where seldom a human showed his face.&lt;/p&gt;
&lt;p&gt;They aren&amp;rsquo;t rare, of course, humans. No, quite the opposite. They simply didn&amp;rsquo;t live long enough. Speakeasies are illegal, you see &amp;ndash; no self respecting elf could be seen drinking with a dwarf, or dare I say, an orc &amp;ndash; so they&amp;rsquo;re not exactly advertised. The humans who helped found these establishments had long since died. They&amp;rsquo;re mayflies, alive just barely long enough to be young, and dead practically as they learned to walk. The new humans since simply hadn&amp;rsquo;t heard of the place.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;There you are, Arthur! It&amp;rsquo;s been a long time since I saw you last!&amp;rdquo;&lt;/p&gt;
&lt;p&gt;The bar quieted once again as she walked in. Drea, high elf, and uncontested beauty. Many pairs of eyes tracked her as she comfortably made her way to the counter, where the human was nursing his second drink.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Has it been that long? Seems like only yesterday,&amp;rdquo; he said.&lt;/p&gt;
&lt;p&gt;A second passed before he cracked a smile.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;But it is nice to see you again, Drea, after all these years. I was beginning to get bored.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;She laughed, embraced him, and for a while they simply enjoyed each other, rocking slightly as they hugged.&lt;/p&gt;
&lt;p&gt;The chatter in the bar changed as the pair caught up. The beautiful, stately high elf laughing as the human told some story, snorting as the ale went up her nose. She was clearly smitten, and many of the larger orcs and stronger dwarves, now more than a little intoxicated, took exception to such a lady falling for a human.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;No!&amp;rdquo; she was saying between laughing spurts, &amp;ldquo;Surely Matt told you it was a bad idea!&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Was it, though? I&amp;rsquo;m telling you, my arms are pretty long, and the River doesn&amp;rsquo;t have any&amp;ndash; Ah, can I help you gentlemen?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;A dwarf had approached the counter in the company of a rather large orc, both wearing faces that shouted &amp;ldquo;I&amp;rsquo;m stricken by her beauty, but I don&amp;rsquo;t want her to know it.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Nae, nae youngster,&amp;rdquo; said the dwarf. &amp;ldquo;I&amp;rsquo;d more like if ye lady friend here&amp;rsquo;d care for another drink! So&amp;rsquo;thing stronger, maybe, with some flavor!&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Aye,&amp;rdquo; the orc boomed, &amp;ldquo;something stronger!&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Arthur quietly admitted to himself, he was impressed with the orc&amp;rsquo;s bulging muscles as he flexed. Drea, apparently, wasn&amp;rsquo;t.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Oh quiet yourselves, my friends. I&amp;rsquo;m afraid you&amp;rsquo;ll have to drink with each other. I am quite taken.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;A fist slammed hard on the counter, &amp;ldquo;By the human?! What can this young thing do that I can&amp;rsquo;t! I can lift a mountain!&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Arthur believed him. He tapped the orc on the shoulder to get his attention, and felt the rock of his muscle.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Aye, my friend,&amp;rdquo; he said, &amp;ldquo;taken by me. I&amp;rsquo;m sure there are others here that would be more receptive of your charm?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Nae,&amp;rdquo; said the dwarf, &amp;ldquo;I wan&#39; te know what makes ye better than us who been buildin&#39; when ye gran&amp;rsquo;father still be suckling milk!&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Ah but we can so easily tell you,&amp;rdquo; said Drea.&lt;/p&gt;
&lt;p&gt;Arthur wasn&amp;rsquo;t so sure. &amp;ldquo;We can?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Sure, sure! Please continue your story.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Ah, now he saw where she was going with this. He swigged his ale and cleared his throat, warming back up to the story.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Aye, so there I was, at the top of the cliff by the bank of the Gaiden&amp;rsquo;s Blood River with my friend Matt. We were looking at the River down below. I&amp;rsquo;ve been swimming in it, and it&amp;rsquo;s gorgeous. It&amp;rsquo;s exactly the perfect temperature and it&amp;rsquo;s so deep and wide you can swim for hours. I really did feel like a swim&amp;ndash; it was getting rather boring up top.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Eyes started widening as Redbeard, and Grukk began to realize where this was going. Gaiden&amp;rsquo;s Blood River, as you probably know, is the largest river in the world. As the story goes, when the blood rushed out from the god Gaiden&amp;rsquo;s wound, the force of it cut such a deep swathe in the earth that its banks are huge cliffs. How the River changed from blood to water is a story for another time, but the cliffs are so high that a dive would surely kill even the most sturdy dwarf.&lt;/p&gt;
&lt;p&gt;Surely he didn&amp;rsquo;t.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Surely ye didn&amp;rsquo;t&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Jump? Of course not! I&amp;rsquo;ve no wish for death. See, we have these things called parachutes &amp;ndash; large cuts of fabric, as large as the largest dining table in the largest hall, that catch the air and slow your fall. But I didn&amp;rsquo;t have a parachute.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Eyes widened again. Such an invention didn&amp;rsquo;t exist among the dwarves or the orcs, and neither Redbeard nor Grukk could think of a more reckless, irresponsible, unsafe thing to do than to fall freely from the sky with nothing but fabric to stop you. Didn&amp;rsquo;t this human have better things to do?&lt;/p&gt;
&lt;p&gt;&amp;ldquo;I didn&amp;rsquo;t have a parachute&amp;ndash;&amp;rdquo;&lt;/p&gt;
&lt;p&gt;The pair sighed in relief.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;&amp;ndash;but our tents were made of the same fabric, so I told Matt to hold my beer, and I cut the damn things into wings from my wrists to my ankles. See, I&amp;rsquo;ve got pretty long arms, and I figure my wingspan would be enough to catch enough air that I could glide down to the River.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;At this point, both sets of eyes were as wide as dinner plates, and Drea was quite amused by the rapt attention with which they were absorbed. She could hardly blame them.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;An&#39; it worked?&amp;rdquo; ventured Redbeard the dwarf. Drea, too, was curious.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Worked?! My friend, it was amazing! It felt like flying! I didn&amp;rsquo;t even bother swimming! Soon as I landed, I climbed the two-day path back up the cliff and I jumped again!&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Drea was the first to break the silence.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;You really are something, aren&amp;rsquo;t you, Arthur.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Human,&amp;rdquo; said the orc, &amp;ldquo;you are lucky to be alive. What drove you to such madness? Why threaten your life?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Aye. Ar&#39; ye mad, ye dumb bastard?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;No, not mad. Just bored.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Bored?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Neither man had ever heard of the term. It must have been some sort of madness to drive a human &amp;ndash; already with so short a life &amp;ndash; to commit to such a danger so readily. They glanced blankly at each other, clearly confused.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;What&amp;rsquo;s bored?&amp;rdquo; they said in unison.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;If I may,&amp;rdquo; said Drea. &amp;ldquo;I can explain.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Arthur gestured for her to go ahead, as he drank his ale.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;You see, humans, and especially Arthur here, occasionally enter a state of mind that drives them to do ridiculous things. I daresay it&amp;rsquo;s a kind of madness, but we&amp;rsquo;ve been arguing about that for ages. There is a very interesting cause to this madness to which all humans succumb.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;She waited a beat, and watched as both men were swallowing nervously.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;It&amp;rsquo;s caused by a lack of threats in their immediate environment. Humans crave threats, you see. Threats to overcome. And that is why, gentlemen, I stand by his side over yours.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Thus leaving both men impressed, Drea grabbed Arthur by the arm, and they walked out of the bar together.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;You are extraordinary, you know,&amp;rdquo; she said, &amp;ldquo;I&amp;rsquo;m very glad I met you. You must&amp;rsquo;ve been mad to approach one such as me, a high elf, so many years ago.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;He kissed her then, smiled, and said &amp;ldquo;No, not mad, my dear. Just bored.&amp;rdquo;&lt;/p&gt;
- https://yogeshdhamija.github.io/writing/mayflies/ - </description>
        </item>
    
    
  </channel>
</rss> 